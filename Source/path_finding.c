/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Program Name: Gatherers (C)                                                                                             //
// Author: Jeffrey Bednar                                                                                                  //
// Copyright (c) Illusion Interactive, 2011 - 2025.                                                                        //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "../Headers/constants.h"
#include "../Headers/entity.h"
#include "../Headers/enums.h"
#include "../Headers/globals.h"
#include "../Headers/heap_allocator.h"
#include "../Headers/log.h"
#include "../Headers/menu.h"
#include "../Headers/misc.h"
#include "../Headers/path_finding.h"
#include "../Headers/process.h"
#include "../Headers/settings.h"
#include "../Headers/Windows/windows_main.h"
#include "../Headers/Windows/windows_minified.h"
#include <float.h>
#include <math.h>
#include <stdlib.h>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PATH_OBSTACLE_Zero(PATH_OBSTACLE_T* p_PathObstacle) {
    ZeroMemory(p_PathObstacle, sizeof(PATH_OBSTACLE_T));
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PATH_OBSTACLE_T* __cdecl PATH_OBSTACLE_Create(GLOBALS_T* p_Globals, LOG_T* p_Log) {
    PATH_OBSTACLE_T* p_PathObstacle = (PATH_OBSTACLE_T*)HEAP_ALLOCATOR_Alloc(p_Globals->p_PathObstacleAllocator, p_Log);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (!p_PathObstacle) {
        MISC_WriteOut(p_Log, LOG_SEVERITY_FATAL, "PATH_OBSTACLE_Create(): Allocation failed.\n");
        UINT8 _discard = MAIN_FailFast(p_Globals, p_Log);
        return NULL;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return p_PathObstacle;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Use MISC_LinkedListFreeAll...
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PATH_OBSTACLE_KillAll(PATH_OBSTACLE_T* p_RootPathObstacle, GLOBALS_T* p_Globals, LOG_T* p_Log) {
    if (p_RootPathObstacle) {
        while (p_RootPathObstacle) {
            PATH_OBSTACLE_T* p_ToFree = p_RootPathObstacle;
            p_RootPathObstacle = p_RootPathObstacle->p_Next;
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            HEAP_ALLOCATOR_Free(p_Globals->p_PathObstacleAllocator, p_ToFree, p_Log);
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Main function to compute a full path. Returns the total path nodes for one or both directions, optionally including interpolated curves.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PATH_T* __cdecl PATH_ComputePath(ENTITY_T* p_Inquirer, FPOINT_T StartPoint, FPOINT_T EndPoint, UINT8 ubIncludeReturnPath, UINT8 ubInterpolateCurves, GLOBALS_T* p_Globals, LOG_T* p_Log, SETTINGS_T* p_Settings) {
    // - Extract a smaller set of obstacles with a bounding box. The bounding box should have a bit of padding.
    // - Sort obstacles in that bounding box to the front because there is a higher likelihood of more workers moving around than structures.
    // - Detect intersections with a main entity along the path, if any.
    // - Find the point to get around the main entity.
    // - Detect intersections to that new point with other entities.
    // - If there's a clear path to that new point, change the starting point to be there and recurse.
    // - Eventually, we'll get to the destination point. This will be the full path.
    // - For each point in the path, interpolate the curve if required.
    if (p_Inquirer->eType != ENTITY_TYPE_WORKER) {
        return NULL;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (p_Globals->eEntitySortState != SORT_ORDER_OBSTACLES_TO_FRONT) {
        ENTITY_SortToFront(SORT_ORDER_OBSTACLES_TO_FRONT, p_Globals, p_Log);
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ENTITY_T* p_CurrentEntity = p_Globals->p_RootEntity;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    PATH_OBSTACLE_T* p_PathObstacle = PATH_OBSTACLE_Create(p_Globals, p_Log);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FDELTA_T Padding = { p_Settings->fPathBoundingBoxPadding, p_Settings->fPathBoundingBoxPadding };
    FRECT_T BoundingBox = PATH_ComputeBoundingBox(StartPoint, EndPoint, &Padding);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    PATH_OBSTACLE_T* p_CurrentPathObstacle = p_PathObstacle;
    PATH_OBSTACLE_T* p_RootPathObstacle = p_PathObstacle;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    while (p_CurrentEntity) {
        if (p_CurrentEntity != p_Inquirer && p_CurrentEntity->ubIsObstacle && PATH_IsWithinBoundingBox(p_CurrentEntity, BoundingBox)) {
            p_CurrentPathObstacle->fDistance = PATH_CalculateDistance(p_Inquirer, p_CurrentEntity);
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Insertion sort...
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            PATH_OBSTACLE_AddAndAdvance(p_CurrentEntity, &p_CurrentPathObstacle, p_Globals, p_Log);
        }
        p_CurrentEntity = p_CurrentEntity->p_Next;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Obstacles or a clear path.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (p_RootPathObstacle) {
        PATH_OBSTACLE_PrintObstaclesList(p_RootPathObstacle, p_Log);
    }
    else {
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    PATH_OBSTACLE_KillAll(p_RootPathObstacle, p_Globals, p_Log);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return NULL;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Checks the provided line segments for intersection.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UINT8 __cdecl PATH_CheckLineIntersection(FPOINT_T PointA1, FPOINT_T PointA2, FPOINT_T PointB1, FPOINT_T PointB2) {
    UINT8 ubIsIntersecting = 0;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    float fDeterminant = (PointB2.fY - PointB1.fY) * (PointA2.fX - PointA1.fX) - (PointB2.fX - PointB1.fX) * (PointA2.fY - PointA1.fY);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Not parallel lines and not collinear.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (fDeterminant != 0.0f) {
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Calculate relative intersections, if any.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        float fSegmentARelative = ((PointB2.fX - PointB1.fX) * (PointA1.fY - PointB1.fY) - (PointB2.fY - PointB1.fY) * (PointA1.fX - PointB1.fX)) / fDeterminant;
        float fSegmentBRelative = ((PointA2.fX - PointA1.fX) * (PointA1.fY - PointB1.fY) - (PointA2.fY - PointA1.fY) * (PointA1.fX - PointB1.fX)) / fDeterminant;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Any intersections will be relative along respective segments.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ubIsIntersecting = (fSegmentARelative >= 0.0f && fSegmentARelative <= 1.0f) && (fSegmentBRelative >= 0.0f && fSegmentBRelative <= 1.0f);
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return ubIsIntersecting;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UINT8 __cdecl PATH_CheckEntityIntersection(FPOINT_T Start, FPOINT_T End, ENTITY_T* p_Entity) {
    FRECT_T EntityRect = { p_Entity->Location, p_Entity->Size };
    return PATH_CheckRectangleIntersection(Start, End, EntityRect);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Future: Only consider visible sides from the perspective of the worker.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UINT8 __cdecl PATH_CheckRectangleIntersection(FPOINT_T Start, FPOINT_T End, FRECT_T Rect) {
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Normalize rect in case of negative size.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////  
    float fLeft = Rect.Location.fX;
    float fRight = Rect.Location.fX + Rect.Size.fDx;
    float fTop = Rect.Location.fY;
    float fBottom = Rect.Location.fY + Rect.Size.fDy;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (fLeft > fRight) {
        float fTemp = fLeft;
        fLeft = fRight;
        fRight = fTemp;
    }
    if (fTop > fBottom) {
        float fTemp = fTop;
        fTop = fBottom;
        fBottom = fTemp;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Both points are outside the rectangle.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if ((Start.fX < fLeft && End.fX < fLeft) || (Start.fX > fRight && End.fX > fRight) ||
        (Start.fY < fTop && End.fY < fTop) || (Start.fY > fBottom && End.fY > fBottom)) {
        return 0;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Both points are inside the rectangle.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (Start.fX >= fLeft && Start.fX <= fRight && Start.fY >= fTop && Start.fY <= fBottom &&
        End.fX >= fLeft && End.fX <= fRight && End.fY >= fTop && End.fY <= fBottom) {
        return 1;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Check for intersections with the rectangle's edges.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FPOINT_T TopLeft = { fLeft, fTop };
    FPOINT_T TopRight = { fRight, fTop };
    FPOINT_T BottomRight = { fRight, fBottom };
    FPOINT_T BottomLeft = { fLeft, fBottom };
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (PATH_CheckLineIntersection(Start, End, TopLeft, TopRight) ||
        PATH_CheckLineIntersection(Start, End, TopRight, BottomRight) ||
        PATH_CheckLineIntersection(Start, End, BottomRight, BottomLeft) ||
        PATH_CheckLineIntersection(Start, End, BottomLeft, TopLeft)) {
        return 1;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // No intersection.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return 0;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Adds a pointer to the obstacle entity and advances the list.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PATH_OBSTACLE_AddAndAdvance(ENTITY_T* p_Entity, PATH_OBSTACLE_T** p_CurrentPathObstacle, GLOBALS_T* p_Globals, LOG_T* p_Log) {
    (*p_CurrentPathObstacle)->p_Entity = p_Entity;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    (*p_CurrentPathObstacle)->p_Next = PATH_OBSTACLE_Create(p_Globals, p_Log);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    (*p_CurrentPathObstacle) = (*p_CurrentPathObstacle)->p_Next;
    (*p_CurrentPathObstacle)->p_Next = NULL;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PATH_OBSTACLE_PrintObstaclesList(PATH_OBSTACLE_T* p_PathObstacles, LOG_T* p_Log) {
    MISC_WriteOut(p_Log, LOG_SEVERITY_TRACE, "--------------------\n");
    USHORT usI = 0;
    PATH_OBSTACLE_T* p_CurrentObstacle = p_PathObstacles;
    while (p_CurrentObstacle && p_CurrentObstacle->p_Entity) {
        ENTITY_T* p_Entity = p_CurrentObstacle->p_Entity;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        MISC_WriteOutParams(p_Log, LOG_SEVERITY_TRACE, "Obstacle Entity [%hu]: ID: %hu, Distance: %0.2f\n", usI, p_Entity->usId, p_CurrentObstacle->fDistance);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        p_CurrentObstacle = p_CurrentObstacle->p_Next;
        usI++;
    }
    MISC_WriteOut(p_Log, LOG_SEVERITY_TRACE, "--------------------\n");
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// When a new obstacle is created, recompute the path for all affected workers that already have a path that intersects with 
// the new entity. Replace the affected pathing points with new ones and interpolate curves if necessary, considering their active
// path vector.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PATH_T* __cdecl PATH_RecomputePath(ENTITY_T* p_NewObstacle, UINT8 ubInterpolateCurves, GLOBALS_T* p_Globals, LOG_T* p_Log) {
    return NULL;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Agnostic to the direction the bounding box is created (i.e. left to right, right to left. etc...).
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FRECT_T __cdecl PATH_ComputeBoundingBox(FPOINT_T StartPoint, FPOINT_T EndPoint, FDELTA_T* p_Padding) {
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Large values to become normalized:
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    float fMinX = FLT_MAX;
    float fMinY = FLT_MAX;
    float fMaxX = FLT_MIN;
    float fMaxY = FLT_MIN;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Normalize within expected points.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (StartPoint.fX < fMinX) fMinX = StartPoint.fX;
    if (StartPoint.fY < fMinY) fMinY = StartPoint.fY;
    if (EndPoint.fX < fMinX) fMinX = EndPoint.fX;
    if (EndPoint.fY < fMinY) fMinY = EndPoint.fY;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (StartPoint.fX > fMaxX) fMaxX = StartPoint.fX;
    if (StartPoint.fY > fMaxY) fMaxY = StartPoint.fY;
    if (EndPoint.fX > fMaxX) fMaxX = EndPoint.fX;
    if (EndPoint.fY > fMaxY) fMaxY = EndPoint.fY;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (p_Padding) {
        fMinX -= p_Padding->fDx;
        fMinY -= p_Padding->fDy;
        fMaxX += p_Padding->fDx;
        fMaxY += p_Padding->fDy;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FDELTA_T Size = { fMaxX - fMinX, fMaxY - fMinY };
    FRECT_T BoundingBox = { {fMinX, fMinY}, Size };
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return BoundingBox;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UINT8 __cdecl PATH_IsWithinBoundingBox(ENTITY_T* p_Entity, FRECT_T BoundingBox) {
    UINT8 ubIsWithinBoundingBox = 0;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (p_Entity->Location.fX >= BoundingBox.Location.fX &&
        p_Entity->Location.fY >= BoundingBox.Location.fY &&
        (p_Entity->Location.fX + p_Entity->Size.fDx) <= (BoundingBox.Location.fX + BoundingBox.Size.fDx) &&
        (p_Entity->Location.fY + p_Entity->Size.fDy) <= (BoundingBox.Location.fY + BoundingBox.Size.fDy)) {
        ubIsWithinBoundingBox = 1;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return ubIsWithinBoundingBox;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PATH_NODE_T* __cdecl PATH_InterpolateCurve(FPOINT_T Intersection, FDELTA_T UnitVectorA, FDELTA_T UnitVectorB, float fArcDistance) {
    // Determine the point that needs an arc interpolation.
    // We have the vectors and unit vectors. From the main intersection point, amplify the unit vectors by a constant to get tangential starting points.
    // Construct the perpendicular by rotating the unit vector 90 degrees.
    // Find the intersection of the perpendiculars (center), then find the distance between that point and a tangent point. That's the radius.
    // Find the unit vectors from center point to tangential points.
    // Calculate the angle between those unit vectors (sweep angle).
    // Divide that angle up into equal segments. These are the arc interpolation vectors.
    // For each segment, rotate a tangential unit vector (CW or CCW), then multiply by radius.
    // Replace the original intersection point with these new interpolated points.
    return NULL;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FDELTA_T __cdecl PATH_CalculateVector(FPOINT_T Start, FPOINT_T Destination) {
    FDELTA_T Vector = { Destination.fX - Start.fX, Destination.fY - Start.fY };
    return Vector;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FDELTA_T __cdecl PATH_CalculateUnitVector(FDELTA_T Vector) {
    float fMagnitude = sqrtf(Vector.fDx * Vector.fDx + Vector.fDy * Vector.fDy);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FDELTA_T UnitVector = {
        Vector.fDx / fMagnitude,
        Vector.fDy / fMagnitude
    };
    return UnitVector;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UINT8 __cdecl PATH_WithinPoint(ENTITY_T* p_Inquirer, FPOINT_T Location) {
    return Location.fX >= p_Inquirer->Location.fX &&
        Location.fX <= p_Inquirer->Location.fX + p_Inquirer->Size.fDx &&
        Location.fY >= p_Inquirer->Location.fY &&
        Location.fY <= p_Inquirer->Location.fY + p_Inquirer->Size.fDy;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PATH_MoveTo(ENTITY_T* p_Source, ENTITY_T* p_Destination, GLOBALS_T* p_Globals, MENU_T* p_Menu, SETTINGS_T* p_Settings) {
    PATH_MoveToPoint(p_Source, p_Destination->CenterPoint, p_Globals, p_Menu, p_Settings);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PATH_MoveToPoint(ENTITY_T* p_Source, FPOINT_T DestinationCenterPoint, GLOBALS_T* p_Globals, MENU_T* p_Menu, SETTINGS_T* p_Settings) {
    p_Source->ubIsInMotion = 1;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Calculate the absolute destination data. This is the major vector.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_Source->MajorDestinationCenterPoint = DestinationCenterPoint;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_Source->MajorVector = PATH_CalculateVector(p_Source->CenterPoint, p_Source->MajorDestinationCenterPoint);
    p_Source->MajorUnitVector = PATH_CalculateUnitVector(p_Source->MajorVector);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Calculate the path-finding destination data. These are the minor vectors needed to reach the major vector.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    PATH_FindMinorVector(p_Source, p_Globals, p_Menu, p_Settings);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PATH_FindMinorVector(ENTITY_T* p_Source, GLOBALS_T* p_Globals, MENU_T* p_Menu, SETTINGS_T* p_Settings) {
    FPOINT_T CurrentPoint = p_Source->CenterPoint;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Minor vector will initially equal the major vector. What if nothing is in the way?
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_Source->MinorDestinationCenterPoint = p_Source->MajorDestinationCenterPoint;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_Source->MinorVector = PATH_CalculateVector(CurrentPoint, p_Source->MinorDestinationCenterPoint);
    p_Source->MinorUnitVector = PATH_CalculateUnitVector(p_Source->MinorVector);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (p_Menu->ubEnablePathFinding) {
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Iterate along the vector to see if I need to change my course.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        while (PATH_IsNotSufficientlyClosePoint(CurrentPoint, p_Source->MinorDestinationCenterPoint, p_Settings)) {
            if (PATH_WithinPoint(p_Source, CurrentPoint)) {
                CurrentPoint.fX += p_Source->MinorUnitVector.fDx;
                CurrentPoint.fY += p_Source->MinorUnitVector.fDy;
                continue;
            }
            else {
                ENTITY_T* p_Current = p_Globals->p_RootEntity;
                while (p_Current && p_Current->ubIsObstacle) {
                    if (PATH_WithinPoint(p_Current, CurrentPoint)) {
                        if (PATH_WithinPoint(p_Current, p_Source->MajorDestinationCenterPoint)) {
                            return;
                        }
                        else {
                            p_Source->MinorDestinationCenterPoint = PATH_FindMinorVectorHead(p_Source, p_Current, p_Globals, p_Settings);
                            /////////////////////////////////////////////////////////////////////////////////////////////////////
                            p_Source->MinorVector = PATH_CalculateVector(p_Source->CenterPoint, p_Source->MinorDestinationCenterPoint);
                            p_Source->MinorUnitVector = PATH_CalculateUnitVector(p_Source->MinorVector);
                            return;
                        }
                    }
                    else {
                        p_Current = (ENTITY_T*)p_Current->p_Next;
                    }
                }
            }
            CurrentPoint.fX += p_Source->MinorUnitVector.fDx;
            CurrentPoint.fY += p_Source->MinorUnitVector.fDy;
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
FPOINT_T __cdecl PATH_FindMinorVectorHead(ENTITY_T* p_Source, ENTITY_T* p_Current, GLOBALS_T* p_Globals, SETTINGS_T* p_Settings) {
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Top left, right, bottom left, right.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FPOINT_T CornerPoints[4] = {
        { p_Current->CenterPoint.fX - p_Current->HalfSize.fDx - p_Source->HalfSize.fDx, p_Current->CenterPoint.fY - p_Current->HalfSize.fDy - p_Source->HalfSize.fDy },
        { p_Current->CenterPoint.fX + p_Current->HalfSize.fDx + p_Source->HalfSize.fDx, p_Current->CenterPoint.fY - p_Current->HalfSize.fDy - p_Source->HalfSize.fDy },
        { p_Current->CenterPoint.fX - p_Current->HalfSize.fDx - p_Source->HalfSize.fDx, p_Current->CenterPoint.fY + p_Current->HalfSize.fDy + p_Source->HalfSize.fDy },
        { p_Current->CenterPoint.fX + p_Current->HalfSize.fDx + p_Source->HalfSize.fDx, p_Current->CenterPoint.fY + p_Current->HalfSize.fDy + p_Source->HalfSize.fDy }
    };
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Calculate the distances to the points, and order the points from closest to farthest from the major destination.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    UINT8 ubI;
    float fDistances[4] = { 0.0f };
    for (ubI = 0; ubI < 4; ubI++) {
        fDistances[ubI] = sqrtf(
            (CornerPoints[ubI].fX - p_Source->MajorDestinationCenterPoint.fX) *
            (CornerPoints[ubI].fX - p_Source->MajorDestinationCenterPoint.fX) +
            (CornerPoints[ubI].fY - p_Source->MajorDestinationCenterPoint.fY) *
            (CornerPoints[ubI].fY - p_Source->MajorDestinationCenterPoint.fY)
        );
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    UINT8 ubJ;
    for (ubI = 0; ubI < 4; ubI++) {
        for (ubJ = 0; ubJ < 3; ubJ++) {
            if (fDistances[ubJ] > fDistances[ubJ + 1]) {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // Swap the distances.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                float fHolder = fDistances[ubJ + 1];
                fDistances[ubJ + 1] = fDistances[ubJ];
                fDistances[ubJ] = fHolder;
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // Swap the coordinates.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                FPOINT_T Holder = CornerPoints[ubJ + 1];
                CornerPoints[ubJ + 1] = CornerPoints[ubJ];
                CornerPoints[ubJ] = Holder;
            }
        }
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Calculate bisections.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Points are ordered to distances from closest to farthest from the major destination point.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    for (ubI = 0; ubI < 4; ubI++) {
        UINT8 ubIsBisection = 0;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FPOINT_T EndPosition = CornerPoints[ubI];
        FPOINT_T CurrentPoint = p_Source->CenterPoint;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        FDELTA_T Vector = PATH_CalculateVector(CurrentPoint, EndPosition);
        FDELTA_T UnitVector = PATH_CalculateUnitVector(Vector);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        while (PATH_IsNotSufficientlyClosePoint(CurrentPoint, EndPosition, p_Settings)) {
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Bisection has occured. This vector is unreachable.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (PATH_WithinPoint(p_Current, CurrentPoint)) {
                ubIsBisection = 1;
                break;
            }
            CurrentPoint.fX += UnitVector.fDx;
            CurrentPoint.fY += UnitVector.fDy;
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // This is the correct head to travel to, but it may contain additional obstacles.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (!ubIsBisection) {
            CurrentPoint = p_Source->CenterPoint;
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            EndPosition = CornerPoints[ubI];
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            Vector = PATH_CalculateVector(CurrentPoint, EndPosition);
            UnitVector = PATH_CalculateUnitVector(Vector);
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            while (PATH_IsNotSufficientlyClosePoint(CurrentPoint, EndPosition, p_Settings)) {
                if (PATH_WithinPoint(p_Source, CurrentPoint)) {
                    CurrentPoint.fX += UnitVector.fDx;
                    CurrentPoint.fY += UnitVector.fDy;
                    continue;
                }
                else {
                    ENTITY_T* p_NewObstacle = p_Globals->p_RootEntity;
                    while (p_NewObstacle && p_NewObstacle->ubIsObstacle) {
                        if (PATH_WithinPoint(p_NewObstacle, CurrentPoint)) {
                            return PATH_FindMinorVectorHead(p_Source, p_NewObstacle, p_Globals, p_Settings);
                        }
                        p_NewObstacle = (ENTITY_T*)p_NewObstacle->p_Next;
                    }
                }
                CurrentPoint.fX += UnitVector.fDx;
                CurrentPoint.fY += UnitVector.fDy;
            }
            return CornerPoints[ubI];
        }
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Should not usually get here. This means the entity was ordered to move while already inside an obstacle.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return CornerPoints[0];
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Updates the position of the entity by amplifying it's unit vector by the movement speed.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl PATH_UpdatePosition(ENTITY_T* p_Entity, GLOBALS_T* p_Globals, MENU_T* p_Menu, SETTINGS_T* p_Settings) {
    p_Entity->Location.fX += p_Entity->MinorUnitVector.fDx * p_Entity->MovementSpeed.fDx;
    p_Entity->Location.fY += p_Entity->MinorUnitVector.fDy * p_Entity->MovementSpeed.fDy;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_Entity->CenterPoint.fX = p_Entity->Location.fX + p_Entity->HalfSize.fDx;
    p_Entity->CenterPoint.fY = p_Entity->Location.fY + p_Entity->HalfSize.fDy;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Minor vectors...
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (PATH_IsSufficientlyCloseMinorVector(p_Entity, p_Settings)) {
        p_Entity->CenterPoint = p_Entity->MinorDestinationCenterPoint;
        p_Entity->Location.fX = p_Entity->MinorDestinationCenterPoint.fX - p_Entity->HalfSize.fDx;
        p_Entity->Location.fY = p_Entity->MinorDestinationCenterPoint.fY - p_Entity->HalfSize.fDy;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Major vector; we've reached our destination...
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (PATH_IsSufficientlyCloseMajorVector(p_Entity, p_Settings)) {
            p_Entity->CenterPoint = p_Entity->MajorDestinationCenterPoint;
            p_Entity->Location.fX = p_Entity->MajorDestinationCenterPoint.fX - p_Entity->HalfSize.fDx;
            p_Entity->Location.fY = p_Entity->MajorDestinationCenterPoint.fY - p_Entity->HalfSize.fDy;
            p_Entity->ubIsInMotion = 0;
        }
        else {
            PATH_FindMinorVector(p_Entity, p_Globals, p_Menu, p_Settings);
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float __cdecl PATH_CalculateDistance(ENTITY_T* p_Inquirer, ENTITY_T* p_Entity) {
    return sqrtf(
        (p_Inquirer->CenterPoint.fX - p_Entity->CenterPoint.fX) *
        (p_Inquirer->CenterPoint.fX - p_Entity->CenterPoint.fX) +
        (p_Inquirer->CenterPoint.fY - p_Entity->CenterPoint.fY) *
        (p_Inquirer->CenterPoint.fY - p_Entity->CenterPoint.fY)
    );
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UINT8 __cdecl PATH_IsSufficientlyCloseMinorVector(ENTITY_T* p_Entity, SETTINGS_T* p_Settings) {
    return PATH_IsSufficientlyClosePoint(p_Entity->CenterPoint, p_Entity->MinorDestinationCenterPoint, p_Settings);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UINT8 __cdecl PATH_IsSufficientlyCloseMajorVector(ENTITY_T* p_Entity, SETTINGS_T* p_Settings) {
    return PATH_IsSufficientlyClosePoint(p_Entity->CenterPoint, p_Entity->MajorDestinationCenterPoint, p_Settings);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UINT8 __cdecl PATH_IsSufficientlyClosePoint(FPOINT_T PointA, FPOINT_T PointB, SETTINGS_T* p_Settings) {
    return
        abs(PointA.fX - PointB.fX) <= p_Settings->fSufficientlyClose &&
        abs(PointA.fY - PointB.fY) <= p_Settings->fSufficientlyClose;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UINT8 __cdecl PATH_IsNotSufficientlyClosePoint(FPOINT_T PointA, FPOINT_T PointB, SETTINGS_T* p_Settings) {
    return
        abs(PointA.fX - PointB.fX) >= p_Settings->fSufficientlyClose ||
        abs(PointA.fY - PointB.fY) >= p_Settings->fSufficientlyClose;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
