/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Program Name: Gatherers (C)                                                                                             //
// Author: Jeffrey Bednar                                                                                                  //
// Copyright (c) Illusion Interactive, 2011 - 2025.                                                                        //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "../Headers/ai.h"
#include "../Headers/common_types.h"
#include "../Headers/constants.h"
#include "../Headers/enums.h"
#include "../Headers/globals.h"
#include "../Headers/heap_allocator.h"
#include "../Headers/log.h"
#include "../Headers/misc.h"
#include "../Headers/settings.h"
#include "../Headers/Windows/windows_minified.h"
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int __cdecl MISC_RandomNumber(int iMinimum, int iMax) {
    return rand() % (iMax - iMinimum + 1) + iMinimum;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float __cdecl MISC_CalculateRadians(CONSTANTS_T* p_Constants, float fDegree) {
    return fDegree * p_Constants->fPi / 180.0f;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl MISC_ResizeWindow(HWND hWnd, UINT uiClientWidth, UINT uiClientHeight, GLOBALS_T* p_Globals) {
    RECT WindowArea;
    RECT ClientArea;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    GetWindowRect(hWnd, &WindowArea);
    GetClientRect(hWnd, &ClientArea);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    UINT uiLRBBorderWidth = (WindowArea.right - WindowArea.left - ClientArea.right) >> 1;
    UINT uiTopBorderWidth = WindowArea.bottom - WindowArea.top - ClientArea.bottom - uiLRBBorderWidth;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Resize the window to the proper size.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MoveWindow(hWnd, 0, 0, uiClientWidth + (uiLRBBorderWidth << 1), uiClientHeight + uiTopBorderWidth + uiLRBBorderWidth, 1);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    GetWindowRect(hWnd, &WindowArea);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Position the window to the center of the main screen.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    IDELTA_T WindowSize = { WindowArea.right - WindowArea.left, WindowArea.bottom - WindowArea.top };
    IDELTA_T HalfWindowSize = { WindowSize.iDx >> 1, WindowSize.iDy >> 1 };
    IPOINT_T MidScreen = { GetSystemMetrics(SM_CXSCREEN) >> 1, GetSystemMetrics(SM_CYSCREEN) >> 1 };
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MoveWindow(hWnd, MidScreen.iX - HalfWindowSize.iDx, MidScreen.iY - HalfWindowSize.iDy, WindowSize.iDx, WindowSize.iDy, 1);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl MISC_FormatTime(ULONG ulSecondsTick, char* p_szBuffer, size_t p_szBufferSize) {
    ULONG ulSeconds = ulSecondsTick % 60;
    ULONG ulMinutes = (ulSecondsTick / 60) % 60;
    ULONG ulHours = (ulSecondsTick / 3600) % 24;
    ULONG ulDays = ulSecondsTick / 86400;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    snprintf(p_szBuffer, p_szBufferSize, "%02lu d %02lu h %02lu m %02lu s", ulDays, ulHours, ulMinutes, ulSeconds);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl MISC_FormatUnsignedWithCommas(char* p_szFormatted, size_t stFormattedSize, unsigned long long ullNumber) {
    char szTemp[32];
    snprintf(szTemp, sizeof(szTemp), "%llu", ullNumber);
    int iSzLength = strlen(szTemp);
    int iFormattedIndex = 0;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    int i;
    for (i = 0; i < iSzLength && iFormattedIndex < (int)stFormattedSize - 1; ++i) {
        p_szFormatted[iFormattedIndex++] = szTemp[i];
        if ((iSzLength - i - 1) % 3 == 0 && i != iSzLength - 1 && iFormattedIndex < (int)stFormattedSize - 1) {
            p_szFormatted[iFormattedIndex++] = ',';
        }
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_szFormatted[iFormattedIndex] = '\0';
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl MISC_FormatSignedWithCommas(char* p_szFormatted, size_t stFormattedSize, long long llNumber) {
    char szTemp[32];
    UINT8 ubIsNegative = llNumber < 0;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Safe bounds for LLONG_MIN.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    unsigned long long ullAbsValue = ubIsNegative
        ? (unsigned long long)(-(llNumber + 1)) + 1
        : (unsigned long long)llNumber;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    snprintf(szTemp, sizeof(szTemp), "%llu", ullAbsValue);
    int iSzLength = strlen(szTemp);
    int iFormattedIndex = 0;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (ubIsNegative && iFormattedIndex < (int)stFormattedSize - 1) {
        p_szFormatted[iFormattedIndex++] = '-';
    }
    int i;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    for (i = 0; i < iSzLength && iFormattedIndex < (int)stFormattedSize - 1; ++i) {
        p_szFormatted[iFormattedIndex++] = szTemp[i];
        if ((iSzLength - i - 1) % 3 == 0 && i != iSzLength - 1 && iFormattedIndex < (int)stFormattedSize - 1) {
            p_szFormatted[iFormattedIndex++] = ',';
        }
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_szFormatted[iFormattedIndex] = '\0';
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
USHORT __cdecl MISC_ClampU16(USHORT usValue, USHORT usMin, USHORT usMax) {
    if (usValue < usMin) return usMin;
    else if (usValue > 65535) return 65535;
    else if (usValue > usMax) return usMax;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return usValue;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ULONG __cdecl MISC_ClampU32(ULONG ulValue, ULONG ulMin, ULONG ulMax) {
    if (ulValue < ulMin) return ulMin;
    else if (ulValue > ulMax) return ulMax;
    return ulValue;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float __cdecl MISC_ClampF32(float fValue, float fMin, float fMax) {
    if (fValue < fMin) return fMin;
    if (fValue > fMax) return fMax;
    if (fValue != fValue) return fMin;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return fValue;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char* __cdecl MISC_Trim(char* p_szValue) {
    if (p_szValue == NULL)
        return NULL;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Advance through leading spaces.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    while (isspace((unsigned char)*p_szValue)) p_szValue++;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // If all spaces...
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (*p_szValue == '\0') return p_szValue;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Rewind through trailing spaces.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    char* p_szEnd = p_szValue + strlen(p_szValue) - 1;
    while (p_szEnd > p_szValue && isspace((unsigned char)*p_szEnd)) p_szEnd--;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Null-terminate the trimmed string.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    *(p_szEnd + 1) = '\0';
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return p_szValue;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl MISC_WriteOut(LOG_T* p_Log, LOG_SEVERITY_T eSeverity, const char* p_szMessage) {
    char szFormatted[4096] = { 0 };
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MISC_FormatWithSeverity(szFormatted, sizeof(szFormatted), eSeverity, p_szMessage);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    printf("%s", szFormatted);
    if (p_Log) {
        LOG_Append(p_Log, szFormatted);
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl MISC_WriteOutParams(LOG_T* p_Log, LOG_SEVERITY_T eSeverity, const char* p_szMessage, ...) {
    char szFormatted[4096] = { 0 };
    char szSeverityPrefixed[4096] = { 0 };
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    va_list vaArgs;
    va_start(vaArgs, p_szMessage);
    vsnprintf(szFormatted, sizeof(szFormatted), p_szMessage, vaArgs);
    va_end(vaArgs);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MISC_FormatWithSeverity(szSeverityPrefixed, sizeof(szSeverityPrefixed), eSeverity, szFormatted);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    printf("%s", szSeverityPrefixed);
    if (p_Log) {
        LOG_Append(p_Log, szSeverityPrefixed);
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl MISC_ReceiveHotReload(SETTINGS_T* p_Settings, GLOBALS_T* p_Globals) {
    MISC_ResizeWindow(p_Globals->hWnd, p_Settings->usInitialClientWidth, p_Settings->usInitialClientHeight, p_Globals);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl MISC_FormatWithSeverity(char* p_szBuffer, size_t stBufferSize, LOG_SEVERITY_T eSeverity, const char* p_szMessage) {
    const char* p_szSeverity = "";
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    switch (eSeverity) {
    case LOG_SEVERITY_TRACE: {
        p_szSeverity = "[INFO]: ";
        break;
    }
    case LOG_SEVERITY_WARNING: {
        p_szSeverity = "[WARN]: ";
        break;
    }
    case LOG_SEVERITY_ERROR: {
        p_szSeverity = "[ERROR]: ";
        break;
    }
    case LOG_SEVERITY_FATAL: {
        p_szSeverity = "[FATAL]: ";
        break;
    }
    default: {
        p_szSeverity = "[UNKNOWN]: ";
        break;
    }
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    snprintf(p_szBuffer, stBufferSize, "%s%s", p_szSeverity, p_szMessage);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char* __cdecl MISC_GetFullPath(const char p_szPath[MAX_PATH], char* p_szFilename, LOG_T* p_Log) {
    static char szFullPath[MAX_PATH];
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (!p_szPath || !p_szFilename) {
        MISC_WriteOut(p_Log, LOG_SEVERITY_ERROR, "MISC_GetFullPath(): Null path or filename provided.\n");
        return NULL;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    strncpy(szFullPath, p_szPath, MAX_PATH);
    szFullPath[MAX_PATH - 1] = '\0';
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    size_t stLength = strlen(szFullPath);
    if (stLength > 0 && szFullPath[stLength - 1] != '\\') {
        if (stLength + 1 >= MAX_PATH) {
            MISC_WriteOut(p_Log, LOG_SEVERITY_ERROR, "MISC_GetFullPath(): Directory path too long to append backslash.\n");
            return NULL;
        }
        szFullPath[stLength++] = '\\';
        szFullPath[stLength] = '\0';
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (stLength + strlen(p_szFilename) >= MAX_PATH) {
        MISC_WriteOut(p_Log, LOG_SEVERITY_ERROR, "MISC_GetFullPath(): Full path would exceed max path.\n");
        return NULL;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    strcat(szFullPath, p_szFilename);
    return szFullPath;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Example usage:
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// T* p_Head = T_GenerateList();
// T Array[X] = { 0 };
// size_t stCount = MISC_LinkedListToArray(p_Head, sizeof(T), Array, X, T_GetNextNode, T_CopyNode); // Or T_CopyNode as null for shallow.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Example traversal functions:
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// void* __cdecl T_GetNextNode(void* vp_Node) {
//     return ((T*)vp_Node)->p_Next;
// }
// void __cdecl T_CopyNode(void* vp_Destination, void* vp_Source) {
//     *((T*)vp_Destination) = *((T*)vp_Source);
// }
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
size_t __cdecl MISC_LinkedListToArray(void* vp_Head, size_t stElementSize, void* vp_DestArray, size_t stMaxElements, GET_NEXT_NODE fnGetNextNode, COPY_NODE fnCopyNode) {
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (!vp_DestArray || !fnGetNextNode || stElementSize == 0 || stMaxElements == 0) {
        return 0;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    size_t stCount = 0;
    char* p_cOut = (char*)vp_DestArray;
    void* vp_Node = vp_Head;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    while (vp_Node && stCount < stMaxElements) {
        void* pDest = p_cOut + stCount * stElementSize;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (fnCopyNode) {
            fnCopyNode(pDest, vp_Node);
        }
        else {
            memcpy(pDest, vp_Node, stElementSize);
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        stCount++;
        vp_Node = fnGetNextNode(vp_Node);
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return stCount;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Example traversal functions:
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// void* __cdecl T_GetNextNode(void* vp_Node) {
//     return ((T*)vp_Node)->p_Next;
// }
// void __cdecl T_SetNextNode(void* vp_Node, void* p_Next) {
//     ((T*)vp_Node)->p_Next = (T*)p_Next;
// }
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl MISC_LinkedListFreeAll(void* vp_Head, HEAP_ALLOCATOR_T* p_Allocator, GET_NEXT_NODE fnGetNextNode, SET_NEXT_NODE fnSetNextNode, LOG_T* p_Log) {
    void* vp_Node = vp_Head;
    while (vp_Node) {
        void* vp_Next = fnGetNextNode(vp_Node);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Optionally clear the next pointer to avoid dangling references.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (fnSetNextNode) {
            fnSetNextNode(vp_Node, NULL);
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        HEAP_ALLOCATOR_Free(p_Allocator, vp_Node, p_Log);
        vp_Node = vp_Next;
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void* __cdecl FPOINT_LIST_GetNextNode(void* vp_Node) {
    return ((FPOINT_LIST_T*)vp_Node)->p_Next;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl FPOINT_LIST_CopyNode(void* vp_Destination, void* vp_Source) {
    *((FPOINT_LIST_T*)vp_Destination) = *((FPOINT_LIST_T*)vp_Source);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl FPOINT_LIST_SetNextNode(void* vp_Node, void* vp_Next) {
    ((FPOINT_LIST_T*)vp_Node)->p_Next = (FPOINT_LIST_T*)vp_Next;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void* __cdecl FRECT_LIST_GetNextNode(void* vp_Node) {
    return ((FRECT_LIST_T*)vp_Node)->p_Next;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl FRECT_LIST_CopyNode(void* vp_Destination, void* vp_Source) {
    *((FRECT_LIST_T*)vp_Destination) = *((FRECT_LIST_T*)vp_Source);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl FRECT_LIST_SetNextNode(void* vp_Node, void* vp_Next) {
    ((FRECT_LIST_T*)vp_Node)->p_Next = (FRECT_LIST_T*)vp_Next;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char* __cdecl MISC_GetRendererTypeName(RENDERER_TYPE_T eType) {
    switch (eType) {
    case RENDERER_TYPE_WIREFRAME: {
        return "RENDERER_TYPE_WIREFRAME";
    }
    case RENDERER_TYPE_SINGLE_BUFFER: {
        return "RENDERER_TYPE_SINGLE_BUFFER";
    }
    case RENDERER_TYPE_DOUBLE_BUFFER: {
        return "RENDERER_TYPE_DOUBLE_BUFFER";
    }
    case RENDERER_TYPE_SDL: {
        return "RENDERER_TYPE_SDL";
    }
    case RENDERER_TYPE_DIRECT2D: {
        return "RENDERER_TYPE_DIRECT2D";
    }
    default: {
        return "RENDERER_TYPE_UNKNOWN";
    }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
