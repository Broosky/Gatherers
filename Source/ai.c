/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Program Name: Gatherers (C)                                                                                             //
// Author: Jeffrey Bednar                                                                                                  //
// Copyright (c) Illusion Interactive, 2011 - 2025.                                                                        //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _AI_C_
#define _AI_C_
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "../Headers/constants.h"
#include "../Headers/functions.h"
#include "../Headers/types.h"
#include <math.h>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ENTITY* __cdecl AI_FindClosest(ENTITY* p_Inquirer, USHORT usType, GLOBALS* p_Globals) {
    ENTITY* p_Closest = NULL;
    ENTITY* p_Current = p_Globals->p_RootEntity;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Map size has changed to 5750 x 5750. The maximum search zone needs to increase.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    float fClosestDistance = AI_MAX_SEARCH_RANGE;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    while (p_Current) {
        if (p_Current->usType == usType && p_Current->ubIsAlive) {
            float fDistance = sqrtf(
                (p_Inquirer->CenterPoint.fX - p_Current->CenterPoint.fX) *
                (p_Inquirer->CenterPoint.fX - p_Current->CenterPoint.fX) +
                (p_Inquirer->CenterPoint.fY - p_Current->CenterPoint.fY) *
                (p_Inquirer->CenterPoint.fY - p_Current->CenterPoint.fY)
            );
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (fDistance < fClosestDistance) {
                fClosestDistance = fDistance;
                p_Closest = p_Current;
            }
        }
        p_Current = (ENTITY*)p_Current->p_Next;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Returns null if no entities of a specific type were found.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return p_Closest;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Allocation adjustments include an extra element to detect a null pointer during enumerations.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
AI_CLOSEST* __cdecl AI_FindClosestByDistance(ENTITY* p_Inquirer, USHORT usType, int* p_iRollingAllocationHeap, USHORT* p_usFound, GLOBALS* p_Globals) {
    USHORT usResizeThresholdCapacity = 5;
    USHORT usCurrentAllocationCount = 0;
    *p_iRollingAllocationHeap = sizeof(AI_CLOSEST) * (usResizeThresholdCapacity + 1);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    AI_CLOSEST* p_ClosestEntities = (AI_CLOSEST*)malloc(*p_iRollingAllocationHeap);
    p_Globals->iRunningHeap += *p_iRollingAllocationHeap;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ENTITY* p_Current = p_Globals->p_RootEntity;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    while (p_Current) {
        if (p_Current->usType == usType && p_Current->ubIsAlive) {
            float fDistance = sqrtf(
                (p_Inquirer->CenterPoint.fX - p_Current->CenterPoint.fX) *
                (p_Inquirer->CenterPoint.fX - p_Current->CenterPoint.fX) +
                (p_Inquirer->CenterPoint.fY - p_Current->CenterPoint.fY) *
                (p_Inquirer->CenterPoint.fY - p_Current->CenterPoint.fY)
            );
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Resize dynamically.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (usCurrentAllocationCount >= usResizeThresholdCapacity) {
                p_Globals->iRunningHeap -= *p_iRollingAllocationHeap;
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                usResizeThresholdCapacity <<= 1;
                *p_iRollingAllocationHeap = sizeof(AI_CLOSEST) * (usResizeThresholdCapacity + 1);
                AI_CLOSEST* p_ClosestEntitiesResized = (AI_CLOSEST*)realloc(p_ClosestEntities, *p_iRollingAllocationHeap);
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                p_Globals->iRunningHeap += *p_iRollingAllocationHeap;
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                p_ClosestEntities = p_ClosestEntitiesResized;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            p_ClosestEntities[usCurrentAllocationCount].p_Entity = p_Current;
            p_ClosestEntities[usCurrentAllocationCount].fDistance = fDistance;
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            usCurrentAllocationCount++;
        }
        p_Current = (ENTITY*)p_Current->p_Next;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Sort ascending.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    qsort(p_ClosestEntities, usCurrentAllocationCount, sizeof(AI_CLOSEST), AI_CompareDistances);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Stopper for when enumerating.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_ClosestEntities[usCurrentAllocationCount].p_Entity = NULL;
    p_ClosestEntities[usCurrentAllocationCount].fDistance = AI_MAX_SEARCH_RANGE;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    *p_usFound = usCurrentAllocationCount;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return p_ClosestEntities;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl AI_HandleWorkers(ENTITY* p_Worker, GLOBALS* p_Globals) {
    if (p_Worker->ubIsCarrying) {
        ENTITY* p_ComCenter = AI_FindClosest(p_Worker, ENTITY_COMMAND, p_Globals);
        if (p_ComCenter) {
            if (ENTITY_CollidedWith(p_Worker, p_ComCenter)) {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // The worker is carrying minerals.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                if (p_Worker->iMineralCount > 0) {
                    USHORT usMessageStyle = MESSAGE_GAIN_MINERALS;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // For fun, have a chance to get a golden mineral.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    if (MISC_RandomNumber(1, 5) >= 5) {
                        p_Worker->iMineralCount += MISC_RandomNumber(1, p_Worker->iMineralCount << MINERALS_MULTIPLIER);
                        usMessageStyle = MESSAGE_BONUS_MINERALS;
                    }
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    snprintf(p_Globals->szBuffer, sizeof(p_Globals->szBuffer), "%d", p_Worker->iMineralCount);
                    MESSAGE_Create(p_Globals->szBuffer, p_Worker->CenterPoint, usMessageStyle, p_Globals);
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    p_Globals->iMineralCount += p_Worker->iMineralCount;
                    p_ComCenter->iMineralCount += p_Worker->iMineralCount;
                    p_Worker->iMineralCount = 0;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Keep them there for a period of time.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ENTITY_Pause(p_Worker, MINERALS_COMMAND_PAUSE);
                    ENTITY_Pause(p_ComCenter, MINERALS_COMMAND_PAUSE);
                }
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // The worker is carrying gas.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                if (p_Worker->iGasCount > 0) {
                    USHORT usMessageStyle = MESSAGE_GAIN_GAS;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // For fun, have a chance to get a golden gas bottle.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    if (MISC_RandomNumber(1, 5) >= 5) {
                        p_Worker->iGasCount += MISC_RandomNumber(1, p_Worker->iGasCount << GAS_MULTIPLIER);
                        usMessageStyle = MESSAGE_BONUS_GAS;
                    }
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    snprintf(p_Globals->szBuffer, sizeof(p_Globals->szBuffer), "%d", p_Worker->iGasCount);
                    MESSAGE_Create(p_Globals->szBuffer, p_Worker->CenterPoint, usMessageStyle, p_Globals);
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    p_Globals->iGasCount += p_Worker->iGasCount;
                    p_ComCenter->iGasCount += p_Worker->iGasCount;
                    p_Worker->iGasCount = 0;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Keep them there for a period of time.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ENTITY_Pause(p_Worker, REFINERY_COMMAND_PAUSE);
                    ENTITY_Pause(p_ComCenter, REFINERY_COMMAND_PAUSE);
                }
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                p_Worker->ubIsCarrying = 0;
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // Reset the workers movement speed.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                p_Worker->MovementSpeed = (FPOINT){ WORKER_MOVE_SPEED, WORKER_MOVE_SPEED };
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // Allow the animation engine to draw particular images.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                p_ComCenter->usState = ANIMATE_COMMAND_RECEIVE;
                p_Worker->usState = ANIMATE_WORKER_NORMAL;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // The worker has NOT collided with the command center.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            else {
                ENTITY_MoveTo(p_Worker, p_ComCenter, p_Globals);
            }
        }
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // This worker is not carrying minerals right now.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    else {
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // True, if the worker has collided with what it was operating on.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (ENTITY_CollidedWith(p_Worker, (ENTITY*)p_Worker->p_Operating)) {
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // What resource did I collide with?
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            switch ((*(ENTITY*)p_Worker->p_Operating).usType) {
            case ENTITY_MINERAL: {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // True, if there is enough minerals to grab.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                if ((*(ENTITY*)p_Worker->p_Operating).iMineralCount >= MINERALS_PER_GRAB) {
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Add minerals grabbed to specific entities.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    (*(ENTITY*)p_Worker->p_Operating).iMineralCount -= MINERALS_PER_GRAB;
                    p_Worker->iMineralCount += MINERALS_PER_GRAB;
                    p_Worker->ubIsCarrying = 1;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Slow the workers movement speed.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    p_Worker->MovementSpeed =
                        (FPOINT){
                            WORKER_MOVE_SPEED / WORKER_MINERAL_DIVISOR,
                            WORKER_MOVE_SPEED / WORKER_MINERAL_DIVISOR
                    };
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Allow the animation engine to draw particular images.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    p_Worker->usState = ANIMATE_WORKER_MINERALS;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Keep them there for a period of time.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ENTITY_Pause(p_Worker, MINERALS_PAUSE);
                    ENTITY_Pause((ENTITY*)p_Worker->p_Operating, MINERALS_PAUSE);
                }
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // There was NOT enough minerals to grab.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                else {
                    ENTITY_DeleteSpecific((ENTITY*)p_Worker->p_Operating, p_Globals);
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Instead of sitting around doing nothing, find them another field to harvest.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ENTITY* p_MinField = AI_FindClosest(p_Worker, ENTITY_MINERAL, p_Globals);
                    if (p_MinField) {
                        p_Worker->p_Operating = (struct ENTITY*)p_MinField;
                    }
                    else {
                        p_Worker->p_Operating = NULL;
                    }
                }
                break;
            }
            case ENTITY_REFINERY: {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // True, if there is enough gas to grab.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                if ((*(ENTITY*)p_Worker->p_Operating).iGasCount >= GAS_PER_GRAB) {
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Add gas grabbed to specific entities.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    (*(ENTITY*)p_Worker->p_Operating).iGasCount -= GAS_PER_GRAB;
                    p_Worker->iGasCount += GAS_PER_GRAB;
                    p_Worker->ubIsCarrying = 1;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Slow the workers movement speed.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    p_Worker->MovementSpeed =
                        (FPOINT){
                            WORKER_MOVE_SPEED / WORKER_GAS_DIVISOR,
                            WORKER_MOVE_SPEED / WORKER_GAS_DIVISOR
                    };
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Allow the animation engine to draw particular images.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    p_Worker->usState = ANIMATE_WORKER_GAS;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Keep them there for a period of time.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ENTITY_Pause(p_Worker, REFINERY_PAUSE);
                    ENTITY_Pause((ENTITY*)p_Worker->p_Operating, REFINERY_PAUSE);
                }
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // There was NOT enough gas to grab.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                else {
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Instead of sitting around doing nothing, find them another field to harvest.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ENTITY* p_Refinery = AI_FindClosest(p_Worker, ENTITY_REFINERY, p_Globals);
                    if (p_Refinery) {
                        p_Worker->p_Operating = (struct ENTITY*)p_Refinery;
                    }
                    else {
                        p_Worker->p_Operating = NULL;
                    }
                }
            }
            }
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The worker has NOT collided with what it was operating on.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        else {
            ENTITY_MoveTo(p_Worker, (ENTITY*)p_Worker->p_Operating, p_Globals);
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int __cdecl AI_CompareDistances(const void* p_EntityA, const void* p_EntityB) {
    AI_CLOSEST* EntityA = (AI_CLOSEST*)p_EntityA;
    AI_CLOSEST* EntityB = (AI_CLOSEST*)p_EntityB;
    return (EntityA->fDistance > EntityB->fDistance) - (EntityA->fDistance < EntityB->fDistance);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
