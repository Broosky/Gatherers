/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Program Name: Gatherers (C)                                                                                             //
// Author: Jeffrey Bednar                                                                                                  //
// Copyright (c) Illusion Interactive, 2011 - 2025.                                                                        //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "../Headers/ai.h"
#include "../Headers/common.h"
#include "../Headers/constants.h"
#include "../Headers/entity.h"
#include "../Headers/globals.h"
#include "../Headers/log.h"
#include "../Headers/main.h"
#include "../Headers/message.h"
#include "../Headers/misc.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ENTITY_T* __cdecl AI_FindClosest(ENTITY_T* p_Inquirer, USHORT usType, GLOBALS_T* p_Globals) {
    ENTITY_T* p_Closest = NULL;
    ENTITY_T* p_Current = p_Globals->p_RootEntity;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Map size has changed to 5750 x 5750. The maximum search zone needs to increase.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    float fClosestDistance = AI_MAX_SEARCH_RANGE;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    while (p_Current) {
        if (p_Current->usType == usType && p_Current->ubIsAlive) {
            float fDistance = sqrtf(
                (p_Inquirer->CenterPoint.fX - p_Current->CenterPoint.fX) *
                (p_Inquirer->CenterPoint.fX - p_Current->CenterPoint.fX) +
                (p_Inquirer->CenterPoint.fY - p_Current->CenterPoint.fY) *
                (p_Inquirer->CenterPoint.fY - p_Current->CenterPoint.fY)
            );
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (fDistance < fClosestDistance) {
                fClosestDistance = fDistance;
                p_Closest = p_Current;
            }
        }
        p_Current = p_Current->p_Next;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Returns null if no entities of a specific type were found.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return p_Closest;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Allocation adjustments include an extra element to detect a null pointer during enumerations.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
AI_CLOSEST_T* __cdecl AI_FindClosestByDistance(ENTITY_T* p_Inquirer, USHORT usType, size_t* p_stAllocationRolling, USHORT* p_usFound, GLOBALS_T* p_Globals, LOG_T* p_Log) {
    USHORT usResizeThresholdCapacity = 5;
    USHORT usCurrentAllocationCount = 0;
    *p_stAllocationRolling = sizeof(AI_CLOSEST_T) * (usResizeThresholdCapacity + 1);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    AI_CLOSEST_T* p_ClosestEntities = malloc(*p_stAllocationRolling);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (!p_ClosestEntities) {
        LOG_AppendParams(p_Log, "AI_FindClosestByDistance(): malloc failed for size: %zu bytes\n", *p_stAllocationRolling);
        UINT _discard = MAIN_FailFast(p_Globals, p_Log);
        return NULL;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_Globals->stAllocations += *p_stAllocationRolling;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ENTITY_T* p_Current = p_Globals->p_RootEntity;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    while (p_Current) {
        if (p_Current->usType == usType && p_Current->ubIsAlive) {
            float fDistance = sqrtf(
                (p_Inquirer->CenterPoint.fX - p_Current->CenterPoint.fX) *
                (p_Inquirer->CenterPoint.fX - p_Current->CenterPoint.fX) +
                (p_Inquirer->CenterPoint.fY - p_Current->CenterPoint.fY) *
                (p_Inquirer->CenterPoint.fY - p_Current->CenterPoint.fY)
            );
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // Resize dynamically.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (usCurrentAllocationCount >= usResizeThresholdCapacity) {
                p_Globals->stAllocations -= *p_stAllocationRolling;
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                usResizeThresholdCapacity <<= 1;
                *p_stAllocationRolling = sizeof(AI_CLOSEST_T) * (usResizeThresholdCapacity + 1);
                AI_CLOSEST_T* p_ClosestEntitiesResized = realloc(p_ClosestEntities, *p_stAllocationRolling);
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                if (!p_ClosestEntitiesResized) {
                    // We've already decremented the heap couter prior to the resize.
                    free(p_ClosestEntities);
                    LOG_AppendParams(p_Log, "AI_FindClosestByDistance(): realloc failed for size: %zu bytes\n", *p_stAllocationRolling);
                    UINT _discard = MAIN_FailFast(p_Globals, p_Log);
                    return NULL;
                }
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                p_Globals->stAllocations += *p_stAllocationRolling;
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                p_ClosestEntities = p_ClosestEntitiesResized;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            p_ClosestEntities[usCurrentAllocationCount].p_Entity = p_Current;
            p_ClosestEntities[usCurrentAllocationCount].fDistance = fDistance;
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            usCurrentAllocationCount++;
        }
        p_Current = p_Current->p_Next;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Sort ascending.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    qsort(p_ClosestEntities, usCurrentAllocationCount, sizeof(AI_CLOSEST_T), AI_CompareDistances);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Stopper for when enumerating.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_ClosestEntities[usCurrentAllocationCount].p_Entity = NULL;
    p_ClosestEntities[usCurrentAllocationCount].fDistance = AI_MAX_SEARCH_RANGE;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    *p_usFound = usCurrentAllocationCount;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return p_ClosestEntities;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl AI_HandleWorkers(ENTITY_T* p_Worker, GLOBALS_T* p_Globals, LOG_T* p_Log) {
    if (p_Worker->ubIsCarrying) {
        ENTITY_T* p_ComCenter = AI_FindClosest(p_Worker, ENTITY_COMMAND, p_Globals);
        if (p_ComCenter) {
            if (ENTITY_CollidedWith(p_Worker, p_ComCenter)) {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // The worker is carrying minerals.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                if (p_Worker->iMineralCount > 0) {
                    USHORT usMessageStyle = MESSAGE_GAIN_MINERALS;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // For fun, have a chance to get a golden mineral.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    if (MISC_RandomNumber(1, 5) >= 5) {
                        p_Worker->iMineralCount += MISC_RandomNumber(1, p_Worker->iMineralCount << MINERALS_MULTIPLIER);
                        usMessageStyle = MESSAGE_BONUS_MINERALS;
                    }
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    snprintf(p_Globals->szBuffer, sizeof(p_Globals->szBuffer), "%d", p_Worker->iMineralCount);
                    MESSAGE_Create(p_Globals->szBuffer, p_Worker->CenterPoint, usMessageStyle, p_Globals, p_Log);
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    p_Globals->iMineralCount += p_Worker->iMineralCount;
                    p_ComCenter->iMineralCount += p_Worker->iMineralCount;
                    p_Worker->iMineralCount = 0;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Keep them there for a period of time.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ENTITY_Pause(p_Worker, MINERALS_COMMAND_PAUSE);
                    ENTITY_Pause(p_ComCenter, MINERALS_COMMAND_PAUSE);
                }
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // The worker is carrying gas.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                if (p_Worker->iGasCount > 0) {
                    USHORT usMessageStyle = MESSAGE_GAIN_GAS;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // For fun, have a chance to get a golden gas bottle.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    if (MISC_RandomNumber(1, 5) >= 5) {
                        p_Worker->iGasCount += MISC_RandomNumber(1, p_Worker->iGasCount << GAS_MULTIPLIER);
                        usMessageStyle = MESSAGE_BONUS_GAS;
                    }
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    snprintf(p_Globals->szBuffer, sizeof(p_Globals->szBuffer), "%d", p_Worker->iGasCount);
                    MESSAGE_Create(p_Globals->szBuffer, p_Worker->CenterPoint, usMessageStyle, p_Globals, p_Log);
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    p_Globals->iGasCount += p_Worker->iGasCount;
                    p_ComCenter->iGasCount += p_Worker->iGasCount;
                    p_Worker->iGasCount = 0;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Keep them there for a period of time.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ENTITY_Pause(p_Worker, REFINERY_COMMAND_PAUSE);
                    ENTITY_Pause(p_ComCenter, REFINERY_COMMAND_PAUSE);
                }
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                p_Worker->ubIsCarrying = 0;
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // Reset the workers movement speed.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                p_Worker->MovementSpeed = (FDELTA_T){ WORKER_MOVE_SPEED, WORKER_MOVE_SPEED };
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // Allow the animation engine to draw particular images.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                p_ComCenter->usState = ANIMATE_COMMAND_RECEIVE;
                p_Worker->usState = ANIMATE_WORKER_NORMAL;
            }
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // The worker has NOT collided with the command center.
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            else {
                ENTITY_MoveTo(p_Worker, p_ComCenter, p_Globals);
            }
        }
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // This worker is not carrying minerals right now.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    else {
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // True, if the worker has collided with what it was operating on.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        if (ENTITY_CollidedWith(p_Worker, p_Worker->p_OperatingTarget)) {
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            // What resource did I collide with?
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            switch ((*(ENTITY_T*)p_Worker->p_OperatingTarget).usType) {
            case ENTITY_MINERAL: {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // True, if there is enough minerals to grab.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                if ((*(ENTITY_T*)p_Worker->p_OperatingTarget).iMineralCount >= MINERALS_PER_GRAB) {
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Add minerals grabbed to specific entities.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    (*(ENTITY_T*)p_Worker->p_OperatingTarget).iMineralCount -= MINERALS_PER_GRAB;
                    p_Worker->iMineralCount += MINERALS_PER_GRAB;
                    p_Worker->ubIsCarrying = 1;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Slow the workers movement speed.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    p_Worker->MovementSpeed =
                        (FDELTA_T){
                            WORKER_MOVE_SPEED / WORKER_MINERAL_DIVISOR,
                            WORKER_MOVE_SPEED / WORKER_MINERAL_DIVISOR
                    };
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Allow the animation engine to draw particular images.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    p_Worker->usState = ANIMATE_WORKER_MINERALS;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Keep them there for a period of time.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ENTITY_Pause(p_Worker, MINERALS_PAUSE);
                    ENTITY_Pause((ENTITY_T*)p_Worker->p_OperatingTarget, MINERALS_PAUSE);
                }
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // There was NOT enough minerals to grab.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                else {
                    ENTITY_DeleteSpecific((ENTITY_T*)p_Worker->p_OperatingTarget, p_Globals);
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Instead of sitting around doing nothing, find them another field to harvest.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ENTITY_T* p_MinField = AI_FindClosest(p_Worker, ENTITY_MINERAL, p_Globals);
                    if (p_MinField) {
                        p_Worker->p_OperatingTarget = (ENTITY_T*)p_MinField;
                    }
                    else {
                        p_Worker->p_OperatingTarget = NULL;
                    }
                }
                break;
            }
            case ENTITY_REFINERY: {
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // True, if there is enough gas to grab.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                if ((*(ENTITY_T*)p_Worker->p_OperatingTarget).iGasCount >= GAS_PER_GRAB) {
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Add gas grabbed to specific entities.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    (*(ENTITY_T*)p_Worker->p_OperatingTarget).iGasCount -= GAS_PER_GRAB;
                    p_Worker->iGasCount += GAS_PER_GRAB;
                    p_Worker->ubIsCarrying = 1;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Slow the workers movement speed.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    p_Worker->MovementSpeed =
                        (FDELTA_T){
                            WORKER_MOVE_SPEED / WORKER_GAS_DIVISOR,
                            WORKER_MOVE_SPEED / WORKER_GAS_DIVISOR
                    };
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Allow the animation engine to draw particular images.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    p_Worker->usState = ANIMATE_WORKER_GAS;
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Keep them there for a period of time.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ENTITY_Pause(p_Worker, REFINERY_PAUSE);
                    ENTITY_Pause((ENTITY_T*)p_Worker->p_OperatingTarget, REFINERY_PAUSE);
                }
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                // There was NOT enough gas to grab.
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                else {
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    // Instead of sitting around doing nothing, find them another field to harvest.
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////
                    ENTITY_T* p_Refinery = AI_FindClosest(p_Worker, ENTITY_REFINERY, p_Globals);
                    if (p_Refinery) {
                        p_Worker->p_OperatingTarget = (ENTITY_T*)p_Refinery;
                    }
                    else {
                        p_Worker->p_OperatingTarget = NULL;
                    }
                }
            }
            }
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // The worker has NOT collided with what it was operating on.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        else {
            ENTITY_MoveTo(p_Worker, (ENTITY_T*)p_Worker->p_OperatingTarget, p_Globals);
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int __cdecl AI_CompareDistances(const void* p_EntityA, const void* p_EntityB) {
    AI_CLOSEST_T* EntityA = (AI_CLOSEST_T*)p_EntityA;
    AI_CLOSEST_T* EntityB = (AI_CLOSEST_T*)p_EntityB;
    return (EntityA->fDistance > EntityB->fDistance) - (EntityA->fDistance < EntityB->fDistance);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
