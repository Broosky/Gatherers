/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Program Name: Gatherers (C)                                                                                             //
// Author: Jeffrey Bednar                                                                                                  //
// Copyright (c) Illusion Interactive, 2011 - 2025.                                                                        //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "../Headers/common.h"
#include "../Headers/globals.h"
#include "../Headers/log.h"
#include <io.h>
#include <stdlib.h>
#include <time.h>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl LOG_Zero(LOG_T* p_Log) {
    ZeroMemory(p_Log, sizeof(LOG_T));
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
LOG_T* __cdecl LOG_Create(const char* p_szFileName, GLOBALS_T* p_Globals) {
    size_t stAlloc = sizeof(LOG_T);
    LOG_T* p_Log = (LOG_T*)malloc(stAlloc);
    if (!p_Log) {
        // This is the only fail fast that writes to console, all others will write to the log.
        printf("LOG_Create(): malloc failed for size: %zu bytes\n", stAlloc);
        return NULL;
    }
    else {
        p_Globals->iRunningHeap += stAlloc;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        LOG_Zero(p_Log);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        // Begin log.
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        p_Log->p_LogFile = fopen(p_szFileName, "a");
        if (p_Log->p_LogFile) {
            char szTimestamp[64] = { 0 };
            LOG_PopulateTimestamp(szTimestamp, sizeof(szTimestamp));
            fprintf(p_Log->p_LogFile, "[%s] %s\n", szTimestamp, "Gatherers starting ===================================");
            LOG_Flush(p_Log, 1);
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            return p_Log;
        }
        else {
            // This is the only fail fast that writes to console, all others will write to the log.
            printf("LOG_Create(): fopen failed.");
            return NULL;
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl LOG_Append(LOG_T* p_Log, const char* p_szMessage) {
    char szTimestamp[64] = { 0 };
    LOG_PopulateTimestamp(szTimestamp, sizeof(szTimestamp));
    fprintf(p_Log->p_LogFile, "[%s] %s\n", szTimestamp, p_szMessage);
    LOG_Flush(p_Log, 1);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl LOG_Flush(LOG_T* p_Log, UINT8 ubGuarantee) {
    fflush(p_Log->p_LogFile);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (ubGuarantee) {
        int iDescriptor = _fileno(p_Log->p_LogFile);
        HANDLE FileHandle = (HANDLE)_get_osfhandle(iDescriptor);
        if (FileHandle != INVALID_HANDLE_VALUE) {
            UINT8 _discard = FlushFileBuffers(FileHandle);
        }
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl LOG_PopulateTimestamp(char* p_szBuffer, size_t stBufferSize) {
    time_t Now = time(NULL);
    struct tm* LocalTime = localtime(&Now);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    strftime(p_szBuffer, stBufferSize, "%Y-%m-%d %H:%M:%S", LocalTime);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl LOG_Kill(LOG_T* p_Log, GLOBALS_T* p_Globals) {
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Bookend log and free.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (p_Log && p_Log->p_LogFile) {
        char szTimestamp[64] = { 0 };
        LOG_PopulateTimestamp(szTimestamp, sizeof(szTimestamp));
        fprintf(p_Log->p_LogFile, "[%s] %s\n\n", szTimestamp, "Gatherers closing ====================================");
        LOG_Flush(p_Log, 1);
        fclose(p_Log->p_LogFile);
    }
    if (p_Log) {
        free(p_Log);
        p_Globals->iRunningHeap -= sizeof(LOG_T);
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
