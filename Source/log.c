/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Program Name: Gatherers (C)                                                                                             //
// Author: Jeffrey Bednar                                                                                                  //
// Copyright (c) Illusion Interactive, 2011 - 2025.                                                                        //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef _LOG_C_
#define _LOG_C_
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "../Headers/functions.h"
#include "../Headers/types.h"
#include <io.h>
#include <time.h>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl LOG_Zero(LOG* p_Log) {
	ZeroMemory(p_Log, sizeof(LOG));
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
LOG* __cdecl LOG_Create(const char* p_szFileName, GLOBALS* p_Globals) {
	size_t stAlloc = sizeof(LOG);
	LOG* p_Log = (LOG*)malloc(stAlloc);
	if (!p_Log) {
		// This is the only fail fast that writes to console, all others will write to the log.
		printf("LOG_Create(): malloc failed for size: %zu bytes\n", stAlloc);
		return NULL;
	}
	else {
		p_Globals->iRunningHeap += stAlloc;
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		LOG_Zero(p_Log);
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Begin log.
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		p_Log->p_LogFile = fopen(p_szFileName, "a");
		if (p_Log->p_LogFile) {
			char szTimestamp[64] = { 0 };
			LOG_PopulateTimestamp(szTimestamp, sizeof(szTimestamp));
			fprintf(p_Log->p_LogFile, "[%s] %s\n", szTimestamp, "Gatherers starting ===================================");
			LOG_Flush(p_Log, 1);
			/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
			return p_Log;
		}
		else {
			// This is the only fail fast that writes to console, all others will write to the log.
			printf("LOG_Create(): fopen failed.");
			return NULL;
		}
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl LOG_Append(LOG* p_Log, const char* p_szMessage) {
	char szTimestamp[64] = { 0 };
	LOG_PopulateTimestamp(szTimestamp, sizeof(szTimestamp));
	fprintf(p_Log->p_LogFile, "[%s] %s\n", szTimestamp, p_szMessage);
	LOG_Flush(p_Log, 1);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl LOG_Flush(LOG* p_Log, UINT8 ubGuarantee) {
	fflush(p_Log->p_LogFile);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if (ubGuarantee) {
		int iDescriptor = _fileno(p_Log->p_LogFile);
		HANDLE FileHandle = (HANDLE)_get_osfhandle(iDescriptor);
		if (FileHandle != INVALID_HANDLE_VALUE) {
			UINT8 _discard = FlushFileBuffers(FileHandle);
		}
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl LOG_PopulateTimestamp(char* p_szBuffer, size_t stBufferSize) {
	time_t Now = time(NULL);
	struct tm* LocalTime = localtime(&Now);
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	strftime(p_szBuffer, stBufferSize, "%Y-%m-%d %H:%M:%S", LocalTime);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl LOG_Kill(LOG* p_Log, GLOBALS* p_Globals) {
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Bookend log and free.
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if (p_Log && p_Log->p_LogFile) {
		char szTimestamp[64] = { 0 };
		LOG_PopulateTimestamp(szTimestamp, sizeof(szTimestamp));
		fprintf(p_Log->p_LogFile, "[%s] %s\n\n", szTimestamp, "Gatherers closing ====================================");
		LOG_Flush(p_Log, 1);
		fclose(p_Log->p_LogFile);
	}
	if (p_Log) {
		free(p_Log);
		p_Globals->iRunningHeap -= sizeof(LOG);
	}
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
