/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Program Name: Gatherers (C)                                                                                             //
// Author: Jeffrey Bednar                                                                                                  //
// Copyright (c) Illusion Interactive, 2011 - 2025.                                                                        //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "../Headers/globals.h"
#include "../Headers/log.h"
#include "../Headers/misc.h"
#include "../Headers/timebase.h"
#include <stdlib.h>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl TIMEBASE_Zero(TIMEBASE_T* p_Timebase) {
    ZeroMemory(p_Timebase, sizeof(TIMEBASE_T));
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
TIMEBASE_T* __cdecl TIMEBASE_Create(float* fRate, GLOBALS_T* p_Globals, LOG_T* p_Log) {
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (fRate && *fRate <= 0.0f) {
        MISC_WriteOut(p_Log, LOG_SEVERITY_FATAL, "TIMEBASE_Create(): Invalid rate.\n");
        return NULL;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    size_t stAllocation = sizeof(TIMEBASE_T);
    TIMEBASE_T* p_Timebase = malloc(stAllocation);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (!p_Timebase) {
        MISC_WriteOutParams(p_Log, LOG_SEVERITY_FATAL, "TIMEBASE_Create(): Malloc failed for size: %zu bytes\n", stAllocation);
        return NULL;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_Globals->stAllocations += stAllocation;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    TIMEBASE_Zero(p_Timebase);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (fRate) {
        TIMEBASE_SetTimings(p_Timebase, *fRate);
    }
    else {
        TIMEBASE_SetCounters(p_Timebase);
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return p_Timebase;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UINT8 __cdecl TIMEBASE_Tick(TIMEBASE_T* p_Timebase) {
    UINT8 ubTicked = 0;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    QueryPerformanceCounter((LARGE_INTEGER*)&p_Timebase->iCountNow);
    p_Timebase->fDifference = (p_Timebase->iCountNow - p_Timebase->iStartCount) / (float)p_Timebase->iFreq;
    if (p_Timebase->fDifference >= p_Timebase->fMsPerFrame) {
        p_Timebase->iStartCount = p_Timebase->iCountNow;
        ubTicked = 1;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return ubTicked;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl TIMEBASE_StartTimer(TIMEBASE_T* p_Timebase) {
    TIMEBASE_Zero(p_Timebase);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    TIMEBASE_SetCounters(p_Timebase);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float __cdecl TIMEBASE_EndTimer(TIMEBASE_T* p_Timebase) {
    QueryPerformanceCounter((LARGE_INTEGER*)&p_Timebase->iCountNow);
    p_Timebase->fDifference = (p_Timebase->iCountNow - p_Timebase->iStartCount) / (float)p_Timebase->iFreq;
    return p_Timebase->fDifference;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl TIMEBASE_ResetTimer(TIMEBASE_T* p_Timebase) {
    p_Timebase->iStartCount = p_Timebase->iCountNow;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl TIMEBASE_SetTimings(TIMEBASE_T* p_Timebase, float fRate) {
    TIMEBASE_SetCounters(p_Timebase);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (fRate) {
        p_Timebase->fMsPerFrame = 1.0f / fRate;
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl TIMEBASE_SetCounters(TIMEBASE_T* p_Timebase) {
    QueryPerformanceFrequency((LARGE_INTEGER*)&p_Timebase->iFreq);
    QueryPerformanceCounter((LARGE_INTEGER*)&p_Timebase->iStartCount);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl TIMEBASE_ReceiveHotReload(TIMEBASE_T* p_Timebase, float fRate) {
    TIMEBASE_SetTimings(p_Timebase, fRate);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl TIMEBASE_Kill(TIMEBASE_T** pp_Timebase, GLOBALS_T* p_Globals) {
    TIMEBASE_T* p_Timebase = *pp_Timebase;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (p_Timebase) {
        free(p_Timebase);
        p_Globals->stAllocations -= sizeof(TIMEBASE_T);
        pp_Timebase = NULL;
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
