/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Program Name: Gatherers (C)                                                                                             //
// Author: Jeffrey Bednar                                                                                                  //
// Copyright (c) Illusion Interactive, 2011 - 2025.                                                                        //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Development notes:
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// - Windows XP does not like the progress bar control created by WinAsm studio. I replaced it with a general label system.
// - Put simple variables that are accessed via dereferencing onto the stack.
// - I no longer use the original taskbar image. Remove it from the loading process.
// - When the process terminates, the operating system will destroy the image objects automatically.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "../Headers/assets.h"
#include "../Headers/card.h"
#include "../Headers/common.h"
#include "../Headers/constants.h"
#include "../Headers/double_buffer.h"
#include "../Headers/engine.h"
#include "../Headers/entity.h"
#include "../Headers/globals.h"
#include "../Headers/log.h"
#include "../Headers/main.h"
#include "../Headers/menu.h"
#include "../Headers/message.h"
#include "../Headers/misc.h"
#include "../Headers/settings.h"
#include "../Headers/timebase.h"
#include "../Headers/transform.h"
#include "../Headers/windows_macros.h"
#include "../Headers/windows_procedure.h"
#include <stdlib.h>
#include <windows.h>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Define externs.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
GLOBALS_T* p_Globals = NULL;
MENU_T* p_Menu = NULL;
LOG_T* p_Log = NULL;
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int WINAPI WinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nCmdShow) {
#if DEBUG
    // Ensure the console is available with Visual Studio (Linker: /SUBSYSTEM:WINDOWS).
    MAIN_LaunchConsole();
#endif
    char szCurrentWorkingDirectory[MAX_PATH];
    if (GetCurrentDirectory(MAX_PATH, szCurrentWorkingDirectory)) {
        printf("Current working directory: %s\n", szCurrentWorkingDirectory);
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_Globals = (GLOBALS_T*)GLOBALS_Create();
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Special case fail-fast for the log system.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_Log = (LOG_T*)LOG_Create("Gatherers.log", p_Globals);
    if (!p_Log) {
        // Unable to create the log file.
        LOG_Kill(p_Log, p_Globals);
        MAIN_Kill(p_Globals);
        TerminateProcess(GetCurrentProcess(), EXIT_FAILURE);
    }
    LOG_Append(p_Log, "File hook successful...");
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_Settings = (SETTINGS_T*)SETTINGS_Create(p_Globals);
    p_Assets = (ASSETS_T*)ASSETS_Create(p_Globals);
    p_Menu = (MENU_T*)MENU_Create(p_Globals);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    SetConsoleTitle(APP_NAME);
    srand(GetTickCount64());
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    WNDCLASSEX WndClassEx;
    ZeroMemory(&WndClassEx, sizeof(WNDCLASSEX));
    WndClassEx.cbSize = sizeof(WNDCLASSEX);
    WndClassEx.style = 0;
    WndClassEx.lpfnWndProc = WINDOWS_PROCEDURE_WindowProc;
    WndClassEx.cbClsExtra = 0;
    WndClassEx.cbWndExtra = 0;
    WndClassEx.hInstance = hInstance;
    WndClassEx.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(ICO_MAIN));
    WndClassEx.hIconSm = WndClassEx.hIcon;
    WndClassEx.hCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_CROSS));
    WndClassEx.hbrBackground = CreateSolidBrush(RGB(100, 100, 100));
    WndClassEx.lpszMenuName = NULL;
    WndClassEx.lpszClassName = APP_NAME;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    RegisterClassEx(&WndClassEx);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DialogBoxParam(hInstance, MAKEINTRESOURCE(DLG_LOAD), NULL, WINDOWS_PROCEDURE_DlgLoad, (LPARAM)WndClassEx.hIcon);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_Menu->hMenu = LoadMenu(hInstance, MAKEINTRESOURCE(MAIN_MENU));
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    GLOBALS_Init(p_Globals, hInstance);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MENU_Init(p_Menu);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    HWND hWnd = CreateWindowEx(
        0,
        APP_NAME,
        APP_NAME,
        WS_OVERLAPPEDWINDOW,
        100,
        100,
        600,
        400,
        NULL,
        p_Menu->hMenu,
        hInstance,
        NULL
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MISC_ResizeWindow(hWnd, INITIAL_CLIENT_WIDTH, INITIAL_CLIENT_HEIGHT);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_DoubleBuffer = DOUBLE_BUFFER_Create(hWnd, p_Globals);
    DOUBLE_BUFFER_SetBlitter(p_DoubleBuffer, &p_Assets->Blitter[0]);
    DOUBLE_BUFFER_Clear(p_DoubleBuffer, RGB(0, 0, 0));
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ShowWindow(hWnd, nCmdShow);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    TIMEBASE_T* p_Engine = (TIMEBASE_T*)TIMEBASE_Create(ENGINE_FPS, p_Globals);
    TIMEBASE_T* p_Seconds = (TIMEBASE_T*)TIMEBASE_Create(1.0f, p_Globals);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    TRANSFORM_Init(p_DoubleBuffer);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    CARD_T* p_Card = (CARD_T*)CARD_Create(p_Globals, p_Assets);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MSG Msg;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    while (1) {
        if (PeekMessage(&Msg, hWnd, 0, 0, PM_REMOVE)) {
            if (Msg.message == WM_QUIT) {
                MAIN_HandleQuit(p_DoubleBuffer, p_Engine, p_Seconds, p_Card, hWnd, p_Globals, p_Assets, p_Menu, p_Settings, p_Log);
                break;
            }
            else {
                TranslateMessage(&Msg);
                DispatchMessage(&Msg);
                /////////////////////////////////////////////////////////////////////////////////////////////////////////////
                MAIN_ConsiderEngine(p_Engine, p_Seconds, p_Card, p_DoubleBuffer, p_Globals, p_Assets, p_Menu);
            }
        }
        else {
            MAIN_ConsiderEngine(p_Engine, p_Seconds, p_Card, p_DoubleBuffer, p_Globals, p_Assets, p_Menu);
        }
    }
    return Msg.wParam;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl MAIN_ConsiderEngine(TIMEBASE_T* p_Engine, TIMEBASE_T* p_Seconds, CARD_T* p_Card, DOUBLE_BUFFER_T* p_DoubleBuffer, GLOBALS_T* p_Globals, ASSETS_T* p_Assets, MENU_T* p_Menu) {
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (TIMEBASE_Tick(p_Engine)) {
        ENGINE_ProcessScene(p_DoubleBuffer, p_Globals, p_Assets, p_Card, p_Menu);
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (TIMEBASE_Tick(p_Seconds)) {
        p_Globals->ulSecondsTick++;
        p_Globals->fFramesPerSecond = (float)p_Globals->ulFrameCount / p_Globals->ulSecondsTick;
        p_Globals->fEngineTimeAverage = p_Globals->fEngineTimeSum * 1000.0f / p_Globals->ulSecondsTick;
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl MAIN_HandleQuit(DOUBLE_BUFFER_T* p_DoubleBuffer, TIMEBASE_T* p_Engine, TIMEBASE_T* p_Seconds, CARD_T* p_Card, HWND hWnd, GLOBALS_T* p_Globals, ASSETS_T* p_Assets, MENU_T* p_Menu, SETTINGS_T* p_Settings, LOG_T* p_Log) {
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Destroy everything the program uses.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ENTITY_DeleteAll(p_Globals);
    MESSAGE_DeleteAll(p_Globals);
    DOUBLE_BUFFER_Kill(p_DoubleBuffer, p_Globals);
    ASSETS_Kill(p_Assets, p_Globals);
    TIMEBASE_Kill(p_Engine, p_Globals);
    TIMEBASE_Kill(p_Seconds, p_Globals);
    CARD_Kill(p_Card, p_Globals);
    SETTINGS_Kill(p_Settings, p_Globals);
    MENU_Kill(p_Menu, p_Globals);
    LOG_Kill(p_Log, p_Globals);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DestroyMenu(p_Menu->hMenu);
    DestroyWindow(hWnd);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MAIN_Kill(p_Globals);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl MAIN_Kill(GLOBALS_T* p_Globals) {
    int iRemainingHeap = GLOBALS_Kill(p_Globals);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (iRemainingHeap) {
        printf("Warning: Remaining heap does not equal zero (%d Bytes).\n", iRemainingHeap);
    }
    else {
        printf("Heap successfully freed.\n");
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Sleep(1750);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl MAIN_LaunchConsole(void) {
    AllocConsole();
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FILE* p_File;
    freopen_s(&p_File, "CONOUT$", "w", stdout);
    freopen_s(&p_File, "CONOUT$", "w", stderr);
    freopen_s(&p_File, "CONIN$", "r", stdin);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
