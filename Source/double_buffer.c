/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Program Name: Gatherers (C)                                                                                             //
// Author: Jeffrey Bednar                                                                                                  //
// Copyright (c) Illusion Interactive, 2011 - 2025.                                                                        //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "../Headers/assets.h"
#include "../Headers/common.h"
#include "../Headers/constants.h"
#include "../Headers/double_buffer.h"
#include "../Headers/entity.h"
#include "../Headers/globals.h"
#include "../Headers/log.h"
#include "../Headers/picture.h"
#include <stdlib.h>
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_Zero(DOUBLE_BUFFER_T* p_DoubleBuffer) {
    ZeroMemory(p_DoubleBuffer, sizeof(DOUBLE_BUFFER_T));
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DOUBLE_BUFFER_T* __cdecl DOUBLE_BUFFER_Create(HWND hWnd, GLOBALS_T* p_Globals, LOG_T* p_Log) {
    size_t stAllocation = sizeof(DOUBLE_BUFFER_T);
    DOUBLE_BUFFER_T* p_DoubleBuffer = malloc(stAllocation);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (!p_DoubleBuffer) {
        LOG_AppendParams(p_Log, "DOUBLE_BUFFER_Create(): malloc failed for size: %zu bytes\n", stAllocation);
        return NULL;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_Globals->stAllocations += stAllocation;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    DOUBLE_BUFFER_Zero(p_DoubleBuffer);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    GetClientRect(hWnd, &p_DoubleBuffer->ClientArea);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_DoubleBuffer->hWnd = hWnd;
    p_DoubleBuffer->hDC = GetDC(p_DoubleBuffer->hWnd);
    p_DoubleBuffer->hDCMem = CreateCompatibleDC(p_DoubleBuffer->hDC);
    p_DoubleBuffer->hDCBmp = CreateCompatibleDC(p_DoubleBuffer->hDC);
    p_DoubleBuffer->hCanvas = CreateCompatibleBitmap(
        p_DoubleBuffer->hDC,
        p_DoubleBuffer->ClientArea.right,
        p_DoubleBuffer->ClientArea.bottom
    );
    p_DoubleBuffer->hStorage = SelectObject(p_DoubleBuffer->hDCMem, p_DoubleBuffer->hCanvas);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return p_DoubleBuffer;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_Resize(DOUBLE_BUFFER_T* p_DoubleBuffer, HWND hWnd, GLOBALS_T* p_Globals) {
    SelectObject(p_DoubleBuffer->hDCMem, p_DoubleBuffer->hStorage);
    DeleteObject(p_DoubleBuffer->hCanvas);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    GetClientRect(hWnd, &p_DoubleBuffer->ClientArea);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    p_DoubleBuffer->hCanvas = CreateCompatibleBitmap(
        p_DoubleBuffer->hDC,
        p_DoubleBuffer->ClientArea.right,
        p_DoubleBuffer->ClientArea.bottom
    );
    p_DoubleBuffer->hStorage = SelectObject(p_DoubleBuffer->hDCMem, p_DoubleBuffer->hCanvas);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_Kill(DOUBLE_BUFFER_T* p_DoubleBuffer, GLOBALS_T* p_Globals) {
    if (p_DoubleBuffer) {
        SelectObject(p_DoubleBuffer->hDCMem, p_DoubleBuffer->hStorage);
        DeleteObject(p_DoubleBuffer->hCanvas);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        DeleteDC(p_DoubleBuffer->hDCBmp);
        DeleteDC(p_DoubleBuffer->hDCMem);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        ReleaseDC(p_DoubleBuffer->hWnd, p_DoubleBuffer->hDC);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        free(p_DoubleBuffer);
        p_Globals->stAllocations -= sizeof(DOUBLE_BUFFER_T);
    }
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
IPOINT_T __cdecl DOUBLE_BUFFER_FindBlitterPoint(char cChar) {
    IPOINT_T CurrentPoint = { 0, 0 };
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Lookup also feasable if the sequencing is not within contiguous ranges.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // abcdefghijklmnopqrstuvwxyz
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (cChar >= 'a' && cChar <= 'z') {
        CurrentPoint.iX = cChar - 'a';
        CurrentPoint.iY = 0;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // ABCDEFGHIJKLMNOPQRSTUVWXYZ
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    else if (cChar >= 'A' && cChar <= 'Z') {
        CurrentPoint.iX = cChar - 'A';
        CurrentPoint.iY = 1;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // 0123456789
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    else if (cChar >= '0' && cChar <= '9') {
        CurrentPoint.iX = cChar - '0';
        CurrentPoint.iY = 2;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //  !"#$%&'()*+,-./ (The first character is a space.)
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    else if (cChar >= 32 && cChar <= 47) {
        CurrentPoint.iX = cChar - 32;
        CurrentPoint.iY = 3;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // :;<=>?@
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    else if (cChar >= 58 && cChar <= 64) {
        CurrentPoint.iX = cChar - 58;
        CurrentPoint.iY = 4;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // [\]^_`
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    else if (cChar >= 91 && cChar <= 96) {
        CurrentPoint.iX = cChar - 91;
        CurrentPoint.iY = 5;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // {|}~
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    else if (cChar >= 123 && cChar <= 126) {
        CurrentPoint.iX = cChar - 123;
        CurrentPoint.iY = 6;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Character not found.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    return CurrentPoint;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_SetBlitter(DOUBLE_BUFFER_T* p_DoubleBuffer, PICTURE_T* p_Picture) {
    p_DoubleBuffer->p_Blitter = p_Picture;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_Blitter(DOUBLE_BUFFER_T* p_DoubleBuffer, char* p_szText, FPOINT_T Location, UINT8 ubMask) {
    const UINT8 ubCharWid = 11;
    const UINT8 ubCharHgt = 22;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Compensate for rendering translations.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Location.fX -= p_DoubleBuffer->XForm.eDx;
    Location.fY -= p_DoubleBuffer->XForm.eDy;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FPOINT_T SavedLocation = Location;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Could put blitter point return into a lookup to avoid same multiplication.
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    if (ubMask) {
        HGDIOBJ hMaskTemp = SelectObject(p_DoubleBuffer->hDCBmp, (*p_DoubleBuffer->p_Blitter).hBmpMask);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        USHORT usI;
        for (usI = 0; usI < strlen(p_szText); usI++) {
            IPOINT_T BlitterPoint = DOUBLE_BUFFER_FindBlitterPoint(p_szText[usI]);
            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            BitBlt(
                p_DoubleBuffer->hDCMem,
                Location.fX,
                Location.fY,
                10,
                16,
                p_DoubleBuffer->hDCBmp,
                BlitterPoint.iX * ubCharWid,
                BlitterPoint.iY * ubCharHgt,
                SRCAND
            );
            Location.fX += ubCharWid;
        }
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        SelectObject(p_DoubleBuffer->hDCBmp, hMaskTemp);
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Location = SavedLocation;
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    HGDIOBJ hPicTemp = SelectObject(p_DoubleBuffer->hDCBmp, (*p_DoubleBuffer->p_Blitter).hBmp);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    USHORT usI;
    for (usI = 0; usI < strlen(p_szText); usI++) {
        IPOINT_T BlitterPoint = DOUBLE_BUFFER_FindBlitterPoint(p_szText[usI]);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        BitBlt(
            p_DoubleBuffer->hDCMem,
            Location.fX,
            Location.fY,
            10,
            16,
            p_DoubleBuffer->hDCBmp,
            BlitterPoint.iX * ubCharWid,
            BlitterPoint.iY * ubCharHgt,
            ubMask ? SRCPAINT : SRCCOPY
        );
        Location.fX += ubCharWid;
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    SelectObject(p_DoubleBuffer->hDCBmp, hPicTemp);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_Clear(DOUBLE_BUFFER_T* p_DoubleBuffer, ASSETS_T* p_Assets) {
    FillRect(p_DoubleBuffer->hDCMem, &p_DoubleBuffer->ClientArea, p_Assets->hBrushBufferClear);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_DrawEntityMinorVector(DOUBLE_BUFFER_T* p_DoubleBuffer, ENTITY_T* p_Entity, ASSETS_T* p_Assets) {
    HPEN hPenTemp = SelectObject(p_DoubleBuffer->hDCMem, p_Assets->hPenMinorVector);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MoveToEx(p_DoubleBuffer->hDCMem, p_Entity->CenterPoint.fX, p_Entity->CenterPoint.fY, NULL);
    LineTo(p_DoubleBuffer->hDCMem, p_Entity->MinorDestinationCenterPoint.fX, p_Entity->MinorDestinationCenterPoint.fY);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    SelectObject(p_DoubleBuffer->hDCMem, hPenTemp);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_DrawEntityMajorVector(DOUBLE_BUFFER_T* p_DoubleBuffer, ENTITY_T* p_Entity, ASSETS_T* p_Assets) {
    HPEN hPenTemp = SelectObject(p_DoubleBuffer->hDCMem, p_Assets->hPenMajorVector);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    MoveToEx(p_DoubleBuffer->hDCMem, p_Entity->CenterPoint.fX, p_Entity->CenterPoint.fY, NULL);
    LineTo(p_DoubleBuffer->hDCMem, p_Entity->MajorDestinationCenterPoint.fX, p_Entity->MajorDestinationCenterPoint.fY);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    SelectObject(p_DoubleBuffer->hDCMem, hPenTemp);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_DrawEntityEllipse(DOUBLE_BUFFER_T* p_DoubleBuffer, ENTITY_T* p_Entity, HPEN hPen, HBRUSH hBrush) {
    HGDIOBJ hPenTemp = SelectObject(p_DoubleBuffer->hDCMem, hPen);
    HGDIOBJ hBrushTemp = SelectObject(p_DoubleBuffer->hDCMem, hBrush);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    Ellipse(
        p_DoubleBuffer->hDCMem,
        p_Entity->CenterPoint.fX - p_Entity->fRadius - COLLISION_BUFFER,
        p_Entity->CenterPoint.fY - p_Entity->fRadius - COLLISION_BUFFER,
        p_Entity->CenterPoint.fX + p_Entity->fRadius + COLLISION_BUFFER,
        p_Entity->CenterPoint.fY + p_Entity->fRadius + COLLISION_BUFFER
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    SelectObject(p_DoubleBuffer->hDCMem, hPenTemp);
    SelectObject(p_DoubleBuffer->hDCMem, hBrushTemp);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Remember: The transform is translated to the center point of the entity to be drawn.
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_DrawEntity(DOUBLE_BUFFER_T* p_DoubleBuffer, ENTITY_T* p_Entity, UINT8 ubMask) {
    if (ubMask) {
        HGDIOBJ hMaskTemp = SelectObject(p_DoubleBuffer->hDCBmp, (*p_Entity->p_Picture).hBmpMask);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        BitBlt(
            p_DoubleBuffer->hDCMem,
            p_Entity->CenterPoint.fX - p_Entity->HalfSize.fDx - p_DoubleBuffer->XForm.eDx,
            p_Entity->CenterPoint.fY - p_Entity->HalfSize.fDy - p_DoubleBuffer->XForm.eDy,
            p_Entity->Size.fDx,
            p_Entity->Size.fDy,
            p_DoubleBuffer->hDCBmp,
            0,
            0,
            SRCAND
        );
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        SelectObject(p_DoubleBuffer->hDCBmp, hMaskTemp);
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    HGDIOBJ hPicTemp = SelectObject(p_DoubleBuffer->hDCBmp, (*p_Entity->p_Picture).hBmp);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    BitBlt(
        p_DoubleBuffer->hDCMem,
        p_Entity->CenterPoint.fX - p_Entity->HalfSize.fDx - p_DoubleBuffer->XForm.eDx,
        p_Entity->CenterPoint.fY - p_Entity->HalfSize.fDy - p_DoubleBuffer->XForm.eDy,
        p_Entity->Size.fDx,
        p_Entity->Size.fDy,
        p_DoubleBuffer->hDCBmp,
        0,
        0,
        ubMask ? SRCPAINT : SRCCOPY
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    SelectObject(p_DoubleBuffer->hDCBmp, hPicTemp);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_ClearEntity(DOUBLE_BUFFER_T* p_DoubleBuffer, ENTITY_T* p_Entity, ASSETS_T* p_Assets) {
    RECT Area = {
        p_Entity->Location.fX,
        p_Entity->Location.fY,
        p_Entity->Location.fX + p_Entity->Size.fDx,
        p_Entity->Location.fY + p_Entity->Size.fDy
    };
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    FillRect(p_DoubleBuffer->hDCMem, &Area, p_Assets->hBrushClear);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_FlipEntity(DOUBLE_BUFFER_T* p_DoubleBuffer, ENTITY_T* p_Entity) {
    BitBlt(
        p_DoubleBuffer->hDC,
        p_Entity->Location.fX,
        p_Entity->Location.fY,
        p_Entity->Size.fDx,
        p_Entity->Size.fDy,
        p_DoubleBuffer->hDCMem,
        p_Entity->Location.fX,
        p_Entity->Location.fY,
        SRCCOPY
    );
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_Flip(DOUBLE_BUFFER_T* p_DoubleBuffer) {
    BitBlt(
        p_DoubleBuffer->hDC,
        0,
        0,
        p_DoubleBuffer->ClientArea.right,
        p_DoubleBuffer->ClientArea.bottom,
        p_DoubleBuffer->hDCMem,
        0,
        0,
        SRCCOPY
    );
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_FlipArea(DOUBLE_BUFFER_T* p_DoubleBuffer, int iX, int iY, int iWidth, int iHeight) {
    BitBlt(p_DoubleBuffer->hDC, iX, iY, iWidth, iHeight, p_DoubleBuffer->hDCMem, iX, iY, SRCCOPY);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_DrawPicture(DOUBLE_BUFFER_T* p_DoubleBuffer, PICTURE_T* p_Picture, UINT8 ubMask) {
    if (ubMask) {
        HGDIOBJ hMaskTemp = SelectObject(p_DoubleBuffer->hDCBmp, p_Picture->hBmpMask);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        BitBlt(
            p_DoubleBuffer->hDCMem,
            p_Picture->Location.fX,
            p_Picture->Location.fY,
            p_Picture->Bitmap.bmWidth,
            p_Picture->Bitmap.bmHeight,
            p_DoubleBuffer->hDCBmp,
            0,
            0,
            SRCAND
        );
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        SelectObject(p_DoubleBuffer->hDCBmp, hMaskTemp);
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    HGDIOBJ hPicTemp = SelectObject(p_DoubleBuffer->hDCBmp, p_Picture->hBmp);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    BitBlt(
        p_DoubleBuffer->hDCMem,
        p_Picture->Location.fX,
        p_Picture->Location.fY,
        p_Picture->Bitmap.bmWidth,
        p_Picture->Bitmap.bmHeight,
        p_DoubleBuffer->hDCBmp,
        0,
        0,
        ubMask ? SRCPAINT : SRCCOPY
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    SelectObject(p_DoubleBuffer->hDCBmp, hPicTemp);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_DrawPictureAt(DOUBLE_BUFFER_T* p_DoubleBuffer, PICTURE_T* p_Picture, FPOINT_T Location, UINT8 ubMask) {
    if (ubMask) {
        HGDIOBJ hMaskTemp = SelectObject(p_DoubleBuffer->hDCBmp, p_Picture->hBmpMask);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        BitBlt(
            p_DoubleBuffer->hDCMem,
            Location.fX,
            Location.fY,
            p_Picture->Bitmap.bmWidth,
            p_Picture->Bitmap.bmHeight,
            p_DoubleBuffer->hDCBmp,
            0,
            0,
            SRCAND
        );
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        SelectObject(p_DoubleBuffer->hDCBmp, hMaskTemp);
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    HGDIOBJ hPicTemp = SelectObject(p_DoubleBuffer->hDCBmp, p_Picture->hBmp);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    BitBlt(
        p_DoubleBuffer->hDCMem,
        Location.fX,
        Location.fY,
        p_Picture->Bitmap.bmWidth,
        p_Picture->Bitmap.bmHeight,
        p_DoubleBuffer->hDCBmp,
        0,
        0,
        ubMask ? SRCPAINT : SRCCOPY
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    SelectObject(p_DoubleBuffer->hDCBmp, hPicTemp);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void __cdecl DOUBLE_BUFFER_CropDrawPictureAt(DOUBLE_BUFFER_T* p_DoubleBuffer, PICTURE_T* p_Picture, FPOINT_T CropStart, FDELTA_T CropDelta, UINT8 ubMask) {
    if (ubMask) {
        HGDIOBJ hMaskTemp = SelectObject(p_DoubleBuffer->hDCBmp, p_Picture->hBmpMask);
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        BitBlt(
            p_DoubleBuffer->hDCMem,
            CropStart.fX,
            CropStart.fY,
            CropDelta.fDx,
            CropDelta.fDy,
            p_DoubleBuffer->hDCBmp,
            0,
            0,
            SRCAND
        );
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        SelectObject(p_DoubleBuffer->hDCBmp, hMaskTemp);
    }
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    HGDIOBJ hPicTemp = SelectObject(p_DoubleBuffer->hDCBmp, p_Picture->hBmp);
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    BitBlt(
        p_DoubleBuffer->hDCMem,
        CropStart.fX,
        CropStart.fY,
        CropDelta.fDx,
        CropDelta.fDy,
        p_DoubleBuffer->hDCBmp,
        0,
        0,
        ubMask ? SRCPAINT : SRCCOPY
    );
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    SelectObject(p_DoubleBuffer->hDCBmp, hPicTemp);
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
